<pre class="metadata">
Title: Payment Method Manifest
Group: W3C
Shortname: payment-method-manifest
Repository: domenic/payment-method-manifest
Status: LD
Editor: Dapeng Liu, Alibaba
Editor: Domenic Denicola, w3cid 52873, Google https://www.google.com/, d@domenic.me, https://domenic.me/
Editor: Zach Koch, w3cid 76588, Google https://www.google.com/
Abstract: This specification defines the machine-readable manifest file describing how a payment
Abstract: method participates in the web payment ecosystem, and how it is to be consumed.
Default Ref Status: current
Complain About: accidental-2119 true, missing-example-ids true
Assume Explicit For: true
Indent: 2
</pre>

<pre class="anchors">
urlPrefix: https://w3c.github.io/browser-payment-api/; spec: PAYMENT-REQUEST; type: dfn
  text: payment method; url: #dfn-payment-method
  text: payment app; url: #dfn-payment-apps
urlPrefix: https://www.w3.org/TR/appmanifest/; spec: APPMANIFEST; type: dfn
  text: web app manifest; url: #dfn-manifest
  text: URL; for: web app manifest; url: #dfn-manifest-url
url: https://w3c.github.io/webpayments-method-identifiers/#; spec: PAYMENT-METHOD-ID; type: dfn
  text: identifier; for: payment method
  text: payment method identifier
</pre>

<!-- TODO: move all this to appropriate working group files in the Bikeshed repo if/when we become
     official. -->
<div boilerplate="copyright">
This document is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/">Creative
Commons Attribution 3.0 License</a>.
</div>

<div boilerplate="status">
This document is merely a public working draft of a potential specification. It has no official
standing of any kind and does not represent the support or consensus of any standards organisation.
</div>

<h2 class="no-num no-toc no-ref" id="status">Status of this document</h2>
<div data-fill-with="status"></div>

<!-- END TODO -->

<div class="non-normative">

<h2 id="introduction">Introduction</h2>

<em>This section and its sub-sections are non-normative.</em>

<h3 id="use-cases">Use cases</h3>

This specification intends to address the following use cases:

* The owner of a [=payment method=] wishes to authorize only certain parties to distribute
  [=payment apps=] that are capable of implementing the payment method. In this use case, the
  browser helps to ensure that for that payment method, the user can only invoke payment apps from
  parties authorized by the owner of the payment method.

* In addition, the owner of a [=payment method=] wishes to confirm the authenticity of a
  particular payment app (e.g., via a digital signature for that app).

* When the user has not yet installed a [=payment app=] for a [=payment method=], the user agent
  can provide an improved user experience for procuring a payment app.

This is accomplished via the requirement that every [=payment method=] whose
[=payment method/identifier=] is a URL will provide a manifest file in JSON format containing two
key pieces of information:

* any default [=payment apps=], if any, that are associated with this [=payment method=],
  referenced as [=absolute-URL strings=] giving the [=web app manifest/URL=] of their
  [=web app manifests=]; and

* any other [=origins=], if any, that are permitted to return back payment credentials for this
  [=payment method=].

<h3 id="accessing">Accessing the manifest</h3>

The resource identified by the [=payment method identifier=] URL does not directly contain the
machine-readable manifest. It is often a generic URL (such as "<code>https://alicepay.com/</code>")
which is more suitable for containing, e.g., a splash page. Instead, a HTTP Link header is used
to direct user agents seeking out the machine-readable manifest to another location. [[RFC5988]]

For an example [=payment method=] AlicePay, with [=payment method identifier=]
"<code>https://alicepay.com/</code>", a user agent might issue a request to that
[=payment method identifier=] URL as follows:

<pre>
  HEAD / HTTP/2
  Host: alicepay.com
  User-Agent: Mellblomenator/9000
</pre>

The server would then respond:

<pre>
  HTTP/2 204
  Link: &lt;/pay/payment-manifest.json>; rel="payment-method-manifest"
</pre>

<h3 id="manifest-example">Example manifest file</h3>

Continuing our example from [[#accessing]], the AlicePay [=payment method=] could provide the
following manifest file at <code>https://alicepay.com/pay/payment-manifest.json</code>:

<pre highlight="json">
{
  "default_applications": ["https://alicepay.com/pay/app/webappmanifest.json"],
  "supported_origins": [
    "https://bobpay.xyz",
    "https://alicepay.friendsofalice.example"
  ]
}
</pre>

This indicates that, if the user agent does not have a [=payment app=] for AlicePay installed, it
can get one by consulting the [=web app manifest=] at
"<code>https://alicepay.com/pay/app/webappmanifest.json</code>".

It also indicates that, apart from this default payment app, AlicePay also allows [=payment apps=]
hosted at the two indicated [=origins=] to be used for AlicePay. This means that if the user agent
ever encounters payment apps hosted at those origins claiming support for AlicePay, it can allow
them to act as payment apps for the AlicePay [=payment method=].

The manifest file could also omit the "<code>supported_origins</code>" key, if no third-party
[=payment apps=] are supported for the [=payment method=] in question, or it could use the value
"<code>*</code>" instead of an array of [=origins=], to indicate that any third party is allowed to
support the payment method.

</div>

<h2 id="processing-model">Processing model</h2>

<h3 id="fetch">Fetching payment method manifests</h3>

To <dfn export>fetch payment method manifests</dfn>, given a [=list=] of [=JavaScript strings=]
|supportedMethods|, perform the following steps. This algorithm will asynchronously complete with
a [=list=] (possibly empty) of [=byte sequences=] containing the contents of any discovered
manifests.

1. Let |identifierURLs| be an empty [=list=].
1. [=list/For each=] |string| of |supportedMethods|:
  1. Let |identifierURL| be the result of [=basic URL parser|basic URL parsing=] |string|. If the
     result is failure, [=iteration/continue=].
  1. If |identifierURL|'s [=url/scheme=] is not "<code>https</code>", [=iteration/continue=].
  1. [=list/Append=] |identifierURL| to |identifierURLs|.
1. Let |manifests| be an empty [=list=].
1. [=list/For each=] |identifierURL| of |identifierURLs|:
  1. Let |identifierRequest| be a new [=request=] whose [=request/method=] is `<code>HEAD</code>`,
     [=request/url=] is |identifierURL|, [=request/client=] is null, [=request/credentials mode=] is
     "<code>omit</code>", and [=request/redirect mode=] is "<code>error</code>".
  1. [=Fetch=] |identifierRequest|. To [=process response=] with the [=response=]
     |identifierResponse|:
    1. If |identifierResponse| is a [=network error=] or |identifierResponse|'s [=response/status=]
       is not an [=ok status=], [=iteration/continue=].
    1. Let |linkHeaders| be the result of
       [=extract header list values|extracting header list values=] given `<code>Link</code>` and
       |identifierResponse|'s [=response/header list=].
    1. [=list/For each=] |linkHeader| of |linkHeaders|:
      1. Parse |linkHeader| according to the <code>link-value</code> production. If it cannot be
         parsed, [=iteration/continue=]. [[!RFC5988]]
      1. If the parsed header contains a parameter whose name is an [=ASCII case-insensitive=] match
         for the string "<code>rel</code>" and whose value is an [=ASCII case-insensitive=] match
         for the string "<code>payment-method-manifest</code>", let |manifestURLString| be the
         string given by the <code>URI-Reference</code> production in the parsed header.
      1. Let |manifestURL| be the result of [=basic URL parser|basic URL parsing=]
         |manifestURLString| with base URL given by |identifierResponse|'s [=response/url=]. If the
         result is failure, [=iteration/continue=].
      1. If |manifestURL|'s [=url/scheme=] is not "<code>https</code>", [=iteration/continue=].
      1. Let |manifestRequest| be a new [=request=] whose [=request/url=] is |manifestURL|,
         [=request/client=] is null, [=request/credentials mode=] is
         "<code>omit</code>", and [=request/redirect mode=] is "<code>error</code>".
      1. [=Fetch=] |manifestRequest|. To [=process response end-of-body=] with the [=response=]
         |manifestResponse|:
         1. Let |body| be |manifestResponse|'s [=response/body=].
         1. If |body| is null, [=iteration/continue=].
         1. Let |reader| be the result of [=ReadableStream/get a reader|getting a reader=] from
            |body|.
         1. Let |promise| be the result of [=ReadableStream/read all bytes|reading all bytes=] from
            |body| with |reader|.
         1. [=Upon fulfillment=] of |promise| with a [=byte sequence=] |bytes|, [=list/append=]
            |bytes| to |manifests|.
1. Once all ongoing [=fetch=] algorithms initiated by the above steps are complete, including the
   specified [=process response=] and [=process response end-of-body=] steps, asynchronously
   complete this algorithm with |manifests|.

<h2 id="acknowledgments" class="no-num">Acknowledgments</h2>

[[#processing-model]] is based heavily on algorithms originally outlined by Rouslan Solomakhin.
