<pre class="metadata">
Title: Payment Method Manifest
Group: W3C
Shortname: payment-method-manifest
Repository: domenic/payment-method-manifest
Status: LD
Editor: Dapeng Liu, Alibaba
Editor: Domenic Denicola, w3cid 52873, Google https://www.google.com/, d@domenic.me, https://domenic.me/
Editor: Zach Koch, w3cid 76588, Google https://www.google.com/
Abstract: This specification defines the machine-readable manifest file describing how a payment
Abstract: method participates in the web payment ecosystem, and how it is to be consumed.
Default Ref Status: current
Complain About: accidental-2119 true, missing-example-ids true
Assume Explicit For: true
Indent: 2
</pre>

<pre class="anchors">
urlPrefix: https://w3c.github.io/browser-payment-api/; spec: PAYMENT-REQUEST; type: dfn
  text: payment method; url: #dfn-payment-method
  text: payment app; url: #dfn-payment-apps
urlPrefix: https://www.w3.org/TR/appmanifest/; spec: APPMANIFEST; type: dfn
  text: web app manifest; url: #dfn-manifest
  text: URL; for: web app manifest; url: #dfn-manifest-url
url: https://w3c.github.io/webpayments-method-identifiers/#; spec: PAYMENT-METHOD-ID; type: dfn
  text: identifier; for: payment method
  text: payment method identifier
urlPrefix: https://tc39.github.io/ecma262/; spec: ECMASCRIPT
  text: %JSON%; type: interface; url: #sec-json-object
  text: parse(); type: method; for: %JSON%; url: #sec-json.parse
  text: JavaScript realm; type: dfn; url: #realm
  type: abstract-op;
    text: CreateListFromArrayLike; url: #sec-createlistfromarraylike
    text: Get; url: #sec-get-o-p
    text: IsArray; url: #sec-isarray
    text: Type; url: #sec-ecmascript-data-types-and-values
</pre>

<!-- TODO: move all this to appropriate working group files in the Bikeshed repo if/when we become
     official. -->
<div boilerplate="copyright">
This document is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/">Creative
Commons Attribution 3.0 License</a>.
</div>

<div boilerplate="status">
This document is merely a public working draft of a potential specification. It has no official
standing of any kind and does not represent the support or consensus of any standards organisation.
</div>

<h2 class="no-num no-toc no-ref" id="status">Status of this document</h2>
<div data-fill-with="status"></div>

<!-- END TODO -->

<div class="non-normative">

<h2 id="introduction">Introduction</h2>

<em>This section and its sub-sections are non-normative.</em>

<h3 id="use-cases">Use cases</h3>

This specification intends to address the following use cases:

* The owner of a [=payment method=] wishes to authorize only certain parties to distribute
  [=payment apps=] that are capable of implementing the payment method. In this use case, the
  browser helps to ensure that for that payment method, the user can only invoke payment apps from
  parties authorized by the owner of the payment method.

* In addition, the owner of a [=payment method=] wishes to confirm the authenticity of a
  particular payment app (e.g., via a digital signature for that app).

* When the user has not yet installed a [=payment app=] for a [=payment method=], the user agent
  can provide an improved user experience for procuring a payment app.

This is accomplished via the requirement that every [=payment method=] whose
[=payment method/identifier=] is a URL will provide a manifest file in JSON format containing two
key pieces of information:

* any default [=payment apps=], if any, that are associated with this [=payment method=],
  referenced as [=absolute-URL strings=] giving the [=web app manifest/URL=] of their
  [=web app manifests=]; and

* any other [=origins=], if any, that are permitted to return back payment credentials for this
  [=payment method=].

<h3 id="accessing">Accessing the manifest</h3>

The resource identified by the [=payment method identifier=] URL does not directly contain the
machine-readable manifest. It is often a generic URL (such as "<code>https://alicepay.com/</code>")
which is more suitable for containing, e.g., a splash page. Instead, a HTTP Link header is used
to direct user agents seeking out the machine-readable manifest to another location. [[RFC5988]]

For an example [=payment method=] AlicePay, with [=payment method identifier=]
"<code>https://alicepay.com/</code>", a user agent might issue a request to that
[=payment method identifier=] URL as follows:

<pre>
  HEAD / HTTP/2
  Host: alicepay.com
  User-Agent: Mellblomenator/9000
</pre>

The server would then respond:

<pre>
  HTTP/2 204
  Link: &lt;/pay/payment-manifest.json>; rel="payment-method-manifest"
</pre>

<h3 id="manifest-example">Example manifest file</h3>

Continuing our example from [[#accessing]], the AlicePay [=payment method=] could provide the
following manifest file at <code>https://alicepay.com/pay/payment-manifest.json</code>:

<pre highlight="json">
{
  "default_applications": ["https://alicepay.com/pay/app/webappmanifest.json"],
  "supported_origins": [
    "https://bobpay.xyz",
    "https://alicepay.friendsofalice.example"
  ]
}
</pre>

This indicates that, if the user agent does not have a [=payment app=] for AlicePay installed, it
can get one by consulting the [=web app manifest=] at
"<code>https://alicepay.com/pay/app/webappmanifest.json</code>".

It also indicates that, apart from this default payment app, AlicePay also allows [=payment apps=]
hosted at the two indicated [=origins=] to be used for AlicePay. This means that if the user agent
ever encounters payment apps hosted at those origins claiming support for AlicePay, it can allow
them to act as payment apps for the AlicePay [=payment method=].

The manifest file could also omit the "<code>supported_origins</code>" key, if no third-party
[=payment apps=] are supported for the [=payment method=] in question, or it could use the value
"<code>*</code>" instead of an array of [=origins=], to indicate that any third party is allowed to
support the payment method.

</div>

<h2 id="processing-model">Processing model</h2>

<h3 id="fetch">Fetching payment method manifests</h3>

To <dfn export>fetch payment method manifests</dfn>, given a [=list=] of [=JavaScript strings=]
|supportedMethods|, perform the following steps. This algorithm will asynchronously complete with
a [=list=] (possibly empty) of [=byte sequences=] containing the contents of any discovered
manifests.

1. Let |identifierURLs| be an empty [=list=].
1. [=list/For each=] |string| of |supportedMethods|:
  1. Let |identifierURL| be the result of [=basic URL parser|basic URL parsing=] |string|. If the
     result is failure, [=iteration/continue=].
  1. If |identifierURL|'s [=url/scheme=] is not "<code>https</code>", [=iteration/continue=].
  1. [=list/Append=] |identifierURL| to |identifierURLs|.
1. Let |manifests| be an empty [=list=].
1. [=list/For each=] |identifierURL| of |identifierURLs|:
  1. Let |identifierRequest| be a new [=request=] whose [=request/method=] is `<code>HEAD</code>`,
     [=request/url=] is |identifierURL|, [=request/client=] is null, [=request/credentials mode=] is
     "<code>omit</code>", and [=request/redirect mode=] is "<code>error</code>".
  1. [=Fetch=] |identifierRequest|. To [=process response=] with the [=response=]
     |identifierResponse|:
    1. If |identifierResponse| is a [=network error=] or |identifierResponse|'s [=response/status=]
       is not an [=ok status=], [=iteration/continue=].
    1. Let |linkHeaders| be the result of
       [=extract header list values|extracting header list values=] given `<code>Link</code>` and
       |identifierResponse|'s [=response/header list=].
    1. Let |manifestURLString| be null.
    1. [=list/For each=] |linkHeader| of |linkHeaders|:
      1. Parse |linkHeader| according to the <code>link-value</code> production. If it cannot be
         parsed, [=iteration/continue=]. [[!RFC5988]]
      1. If the parsed header contains a parameter whose name is an [=ASCII case-insensitive=] match
         for the string "<code>rel</code>" and whose value is an [=ASCII case-insensitive=] match
         for the string "<code>payment-method-manifest</code>", then set |manifestURLString| to the
         string given by the <code>URI-Reference</code> production in the parsed header, and
         [=iteration/break=].
    1. If |manifestURLString| is not null, then:
      1. Let |manifestURL| be the result of [=basic URL parser|basic URL parsing=]
         |manifestURLString| with base URL given by |identifierResponse|'s [=response/url=]. If the
         result is failure, [=iteration/continue=].
      1. If |manifestURL|'s [=url/scheme=] is not "<code>https</code>", [=iteration/continue=].
      1. Let |manifestRequest| be a new [=request=] whose [=request/url=] is |manifestURL|,
         [=request/client=] is null, [=request/credentials mode=] is
         "<code>omit</code>", and [=request/redirect mode=] is "<code>error</code>".
      1. [=Fetch=] |manifestRequest|. To [=process response end-of-body=] with the [=response=]
         |manifestResponse|:
         1. Let |body| be |manifestResponse|'s [=response/body=].
         1. If |body| is null, [=iteration/continue=].
         1. Let |reader| be the result of [=ReadableStream/get a reader|getting a reader=] from
            |body|.
         1. Let |promise| be the result of [=ReadableStream/read all bytes|reading all bytes=] from
            |body| with |reader|.
         1. [=Upon fulfillment=] of |promise| with a [=byte sequence=] |bytes|, [=list/append=]
            |bytes| to |manifests|.
1. Once all ongoing [=fetch=] algorithms initiated by the above steps are complete, including the
   specified [=process response=] and [=process response end-of-body=] steps, asynchronously
   complete this algorithm with |manifests|.

<h3 id="validate-and-parse">Validating and parsing payment method manifests</h3>

A <dfn export>parsed payment method manifest</dfn> is a [=struct=] containing two fields:

: <dfn export for="parsed payment method manifest">default applications</dfn>
:: An [=ordered set=] of [=URLs=], possibly empty
: <dfn export for="parsed payment method manifest">supported origins</dfn>
:: Either the string "<code>*</code>", or an [=ordered set=] of [=origins=]

To <dfn export lt="validate and parse a payment method manifest">validate and parse</dfn> a
[=byte sequence=] |bytes| purporting to contain a payment method manifest, perform the following
steps. The result will either be a [=parsed payment method manifest=], or failure.

1. Let |string| be the result of [=UTF-8 decode|UTF-8 decoding=] |bytes|.
1. Let |parsed| be the result of invoking the initial value of the {{%JSON%/parse()}} method of
   the {{%JSON%}} object on |string|, in a user-agent defined [=JavaScript realm=]. If this throws
   an exception, return failure.
1. If <a abstract-op>Type</a>(|parsed|) is not Object, return failure.
1. Let |defaultApps| be an empty [=ordered set=].
1. Let |defaultAppsValue| be <a abstract-op>Get</a>(|parsed|, "default_applications").
1. If |defaultAppsValue| is not undefined:
  1. If <a abstract-op>IsArray</a>(|defaultAppsValue|) is false, return failure.
  1. Let |defaultAppsList| be <a abstract-op>CreateListFromArrayLike</a>(|defaultAppsValue|,
     « String »). If this throws an exception, return failure.
  1. If the [=list/size=] of |defaultAppsList| is 0, return failure.
  1. [=list/For each=] |defaultAppString| in |defaultAppsList|:
    1. Let |defaultAppURL| be the result of [=basic URL parser|basic URL parsing=]
       |defaultAppString|. If the result is failure, return failure.
    1. If |defaultAppURL|'s [=url/scheme=] is not "<code>https</code>", return failure.
    1. [=set/Append=] |defaultAppURL| to |defaultApps|.
1. Let |supportedOrigins| be an empty [=ordered set=].
1. Let |supportedOriginsValue| be <a abstract-op>Get</a>(|parsed|, "supported_origins").
1. If |supportedOriginsValue| is "<code>*</code>", set |supportedOrigins| to "<code>*</code>".
1. Otherwise, if |supportedOriginsValue| is not undefined:
  1. If <a abstract-op>IsArray</a>(|supportedOriginsValue|) is false, return failure.
  1. Let |supportedOriginsList| be
     <a abstract-op>CreateListFromArrayLike</a>(|supportedOriginsValue|, « String »). If this throws
     an exception, return failure.
  1. If the [=list/size=] of |supportedOriginsList| is 0, return failure.
  1. [=list/For each=] |supportedOriginString| in |supportedOriginsList|:
    1. Let |supportedOriginURL| be the result of [=basic URL parser|basic URL parsing=]
       |supportedOriginString|. If the result is failure, return failure.
    1. If |supportedOriginURL|'s [=url/scheme=] is not "<code>https</code>", return failure.
    1. If |supportedOriginURL|'s [=url/username=] or [=url/password=] are not the empty string,
       return failure.
    1. If |supportedOriginURL|'s [=url/path=]'s [=list/size=] is not 0, return failure.
    1. If |supportedOriginURL|'s [=url/query=] or [=url/fragment=] are not null, return failure.
    1. [=set/Append=] |supportedOriginURL|'s [=url/origin=] to |supportedOrigins|.
1. Return a new [=parsed payment method manifest=] with
   [=parsed payment method manifest/default applications=] given by |defaultApps| and
   [=parsed payment method manifest/supported origins=] given by |supportedOrigins|.

<div class="note">
  Empty arrays for "<code>default_applications</code>" or "<code>supported_origins</code>"
  will cause parsing to fail. That is, this is not a valid manifest:

  <pre highlight="json">
  {
    "default_applications": ["https://alicepay.com/pay/app/webappmanifest.json"],
    "supported_origins": []
  }
  </pre>
</div>


<h2 id="acknowledgments" class="no-num">Acknowledgments</h2>

[[#processing-model]] is based heavily on algorithms originally outlined by Rouslan Solomakhin.
